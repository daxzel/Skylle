import org.vertx.java.platform.impl.cli.Starter


allprojects {
    ext.programDir = "$rootDir/build/program"
}

apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'idea'

def cpSeparator = System.getProperty("path.separator")

loadProperties("${System.getProperty('user.homer')}/.gradle/gradle.properties")

group = modowner
archivesBaseName = modname

defaultTasks = ['assemble']

sourceCompatibility = '1.7'
targetCompatibility = '1.7'

project.ext.moduleName = "$modowner~$modname~$version"

configurations {
    provided
    testCompile.extendsFrom provided
}

repositories {
    mavenLocal()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
    mavenCentral()
}

dependencies {
    provided "io.vertx:vertx-core:$vertxVersion"
    provided "io.vertx:vertx-platform:$vertxVersion"
    testCompile "junit:junit:$junitVersion"
    testCompile "io.vertx:testtools:$toolsVersion"
}

buildscript {

    repositories {
        mavenLocal()
        maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
        mavenCentral()
    }

    dependencies {
        classpath "io.vertx:vertx-core:$vertxVersion"
        classpath "io.vertx:vertx-platform:$vertxVersion"
        classpath "io.vertx:vertx-hazelcast:$vertxVersion"
        classpath files(['src/main/resources'])
        classpath 'com.eriwen:gradle-js-plugin:1.9.0'
    }
}

apply plugin: 'js'

sourceSets {
    main {
        compileClasspath = compileClasspath + configurations.provided
    }
}

javascript.source {
    dev {
        js {
            srcDir 'src/main/resources/static/js'
            include "*.js"
//            exclude "*.min.js"
        }
    }
    prod {
        js {
            srcDir 'src/main/resources/static/js'
            include "*.min.js"
        }
    }
}

def jsSourcesInstaloggerTemp = []
['application.js', 'services/messageServers.js', 'services/repeatedMessages.js', 'services/logLevels.js',
        'services/serverEvents.js', 'services/socket.js', 'services/unreadErrorMessages.js',
        'controllers/messagesController.js', 'controllers/dialogController.js', 'directives/serverPing.js',
        'filters/byServer.js', 'directives/logMessage.js', 'directives/serverPing.js'].each {
    jsSourcesInstaloggerTemp.add('src/main/resources/static/js/application/' + it)
}
def jsSourcesInstalogger = files(jsSourcesInstaloggerTemp)

task combineJsInstalogger(type: com.eriwen.gradle.js.tasks.CombineJsTask) {
    String jsSrcDir = 'src/main/resources/static/js/'
    def tempSources = []
    ['jquery.js', 'ZeroClipboard.min.js', 'sockjs.js', 'angular.min.js', 'angular-sanitize.min.js', 'vertxbus-2.1.js',
            'angular-sanitize.min.js', 'angular-animate.min.js', 'angular-resource.min.js', 'angular-clip.js',
            'ui-bootstrap.min.js', 'tinycon.min.js'].each {
        tempSources.add(jsSrcDir + it)
    }

    source = files(tempSources) + jsSourcesInstalogger
    dest = file("build/compiledResources/static/js/all.js")
}

task jsHintJsInstalogger(type: com.eriwen.gradle.js.tasks.JsHintTask) {
    source = jsSourcesInstalogger
    ignoreExitCode = true
    outputToStdOut = true
}

task copyResources(type: Copy) {
    into 'build/compiledResources/'
    from 'src/main/resources'
    exclude 'static/js'
}

task copyMod(type: Copy, dependsOn: ['classes', 'copyResources', 'jsHintJsInstalogger', 'combineJsInstalogger'], description: 'Assemble the module into the local mods directory') {
    into "build/mods/$moduleName"
    from compileJava
    from 'build/compiledResources'
    into('lib') {
        from configurations.compile
    }
}

task modZip(type: Zip, dependsOn: 'pullInDeps', description: 'Package the module .zip file') {
    group = 'vert.x'
    classifier = "mod"
    description = "Assembles a vert.x module"
    destinationDir = project.file('build/libs')
    archiveName = "${modname}-${version}" + ".zip"
    from copyMod
}

def runModWithClasspath(String classpath) {
    setSysProps()
    def args = ['runmod', moduleName]
    def args2 = ['-conf', "$projectDir/conf.json"]
    boolean ignoring = false
    for (String arg : args2) {
        if (arg == '-cp') {
            ignoring = true
        } else if (!ignoring) {
            args.add(arg)
        } else {
            ignoring = false
        }
    }
    args.add('-cp')
    args.add(classpath)
    Starter.main(args as String[])
}

task runModIDEA(dependsOn: copyMod, description: 'Run the module from the resources in IntelliJ') << {
    runModWithClasspath(project.file("build/mods/$moduleName").path);
}

task start(dependsOn: copyMod, description: 'Run the module using all the build dependencies (not using installed vertx') << {
    setSysProps()
    def args = ['runmod', moduleName]
    def args2 = runModArgs.split("\\s+")
    args.addAll(args2)
    Starter.main(args as String[])
}

task pullInDeps(dependsOn: copyMod, description: 'Pull in all the module dependencies for the module into the nested mods directory') << {
    if (pullInDeps == 'true') {
        setSysProps()
        def args = ['pulldeps', moduleName]
        Starter.main(args as String[])
    }
}

def log4jModule = project('instalogger-log4j')

configure(log4jModule) {
    apply plugin: 'java'

    task log4jJar(dependsOn: classes, type: Jar) {
        destinationDir = file(programDir + '/integration')
        from log4jModule.sourceSets.main.output.classesDir
    }
}

task copyExecutable(type: Copy, description: 'Copy executable files (exe and sh) to result dir') {
    into programDir
    from "program"
}

task fatJar(dependsOn: modZip, description: 'Creates a fat executable jar which contains everything needed to run the module') << {
    setSysProps()
    def args = ['fatjar', moduleName, '-d', programDir]
    Starter.main(args as String[])
}



task renameFatJar(type: Copy, dependsOn: fatJar) {
    from programDir
    into programDir
    rename { String fileName ->
        fileName = "instalogger.jar"
    }
    include '*.jar'
}

task moveFatJar(type: Delete, dependsOn: renameFatJar) {
    delete fileTree('src') {
        from programDir
        include '*fat.jar'
    }
}

task assembleApp(dependsOn: [moveFatJar, copyExecutable, log4jModule.log4jJar]) {

}

def setSysProps() {
    System.setProperty("vertx.clusterManagerFactory", "org.vertx.java.spi.cluster.impl.hazelcast.HazelcastClusterManagerFactory")
    System.setProperty("vertx.mods", "build/mods")
}

def loadProperties(String sourceFileName) {
    def config = new Properties()
    def propFile = new File(sourceFileName)
    if (propFile.canRead()) {
        config.load(new FileInputStream(propFile))
        for (Map.Entry property in config) {
            project.ext[property.key] = property.value;
        }
    }
}

plugins.withType(IdeaPlugin) {
    idea {
        module {
            scopes.PROVIDED.plus += configurations.provided
            scopes.COMPILE.minus += configurations.provided
            scopes.TEST.minus += configurations.provided
            scopes.RUNTIME.minus += configurations.provided
        }
    }
}


buildscript {
    dependencies {
        classpath 'org.jooq:jooq-meta:3.2.0'
        classpath 'org.jooq:jooq-codegen:3.2.0'
        classpath 'org.jooq:jooq:3.2.0'
        classpath 'postgresql:postgresql:9.1-901.jdbc4'
    }
}


import org.jooq.util.GenerationTool
import org.jooq.util.jaxb.Configuration as JooqConfiguration
import org.jooq.util.jaxb.Generator
import org.jooq.util.jaxb.Database
import org.jooq.util.jaxb.Target
import org.jooq.util.jaxb.Jdbc
import javax.xml.bind.JAXB

task generateJooq() << {
    def jdbc = new Jdbc();
    def generator = new Generator();
    def configuration = new JooqConfiguration();
    def target = new Target();
    def database = new Database();

    def driver = org.postgresql.Driver.find();
    println("Found driver " + driver)
    def clazz = Thread.currentThread().getContextClassLoader().loadClass('org.postgresql.Driver')
    println("Found clazz " + clazz)

    jdbc.setDriver('org.postgresql.Driver')
    jdbc.setUrl("jdbc:postgresql://localhost/instalogger")
    jdbc.setUser("root")
    jdbc.setPassword("root")

    target.setDirectory("${rootDir}/src/main/java")
    target.setPackageName("com.instalogger.entities.generated")
    generator.setTarget(target)

    database.setInputSchema("public")
    database.setName("org.jooq.util.postgres.PostgresDatabase")
    database.setIncludes(".*")

    generator.setDatabase(database)

    configuration.setGenerator(generator)
    configuration.setJdbc(jdbc);


    StringWriter writer = new StringWriter();
    JAXB.marshal(configuration, writer);

    println("Using this configuration:\n" + writer.toString());
    GenerationTool.main(configuration);
}

dependencies {
    compile "org.codehaus.groovy:groovy-all:$groovyVersion"
    compile "io.vertx:lang-groovy:$groovyLangModVersion@jar"
    compile "org.jooq:jooq:3.2.0"
    compile "postgresql:postgresql:9.1-901.jdbc4"
    compile "com.google.guava:guava:15.0"
    compile 'org.apache.lucene:lucene-core:4.6.0'
    compile 'org.apache.lucene:lucene-analyzers-common:4.6.0'
    compile 'org.apache.lucene:lucene-queryparser:4.6.0'
    compile 'org.apache.lucene:lucene-memory:4.6.0'
}

