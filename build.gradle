
import org.vertx.java.platform.impl.cli.Starter


allprojects {
    ext.programDir = "$rootDir/build/program"
}

apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'idea'

def cpSeparator = System.getProperty("path.separator")

loadProperties("${System.getProperty('user.homer')}/.gradle/gradle.properties")

group = modowner
archivesBaseName = modname

defaultTasks = ['assemble']

sourceCompatibility = '1.7'
targetCompatibility = '1.7'

project.ext.moduleName = "$modowner~$modname~$version"

configurations {
    provided
    testCompile.extendsFrom provided
}

repositories {
    mavenLocal()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
    mavenCentral()
}

dependencies {
    provided "io.vertx:vertx-core:$vertxVersion"
    provided "io.vertx:vertx-platform:$vertxVersion"
    testCompile "junit:junit:$junitVersion"
    testCompile "io.vertx:testtools:$toolsVersion"
}

buildscript {

    repositories {
        mavenLocal()
        maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
        mavenCentral()
    }

    dependencies {
        classpath "io.vertx:vertx-core:$vertxVersion"
        classpath "io.vertx:vertx-platform:$vertxVersion"
        classpath "io.vertx:vertx-hazelcast:$vertxVersion"
        classpath files(['src/main/resources'])
    }
}

sourceSets {
    main {
        compileClasspath = compileClasspath + configurations.provided
    }
}

task copyMod( type:Copy, dependsOn: 'classes', description: 'Assemble the module into the local mods directory' ) {
    into "build/mods/$moduleName"
    from compileJava
    from 'src/main/resources'
    into( 'lib' ) {
        from configurations.compile
    }
}

task modZip( type: Zip, dependsOn: 'pullInDeps', description: 'Package the module .zip file') {
    group = 'vert.x'
    classifier = "mod"
    description = "Assembles a vert.x module"
    destinationDir = project.file('build/libs')
    archiveName = "${modname}-${version}" + ".zip"
    from copyMod
}

task runModIDEA(dependsOn: copyMod, description: 'Run the module from the resources in IntelliJ') << {
    runModWithClasspath("src/main/resources/src/main/resources/${cpSeparator}src/test/resources/${cpSeparator}" +
            "out/production/${project.name}/${cpSeparator}out/test/${project.name}/");
}

def runModWithClasspath(String classpath) {
    setSysProps()
    def args = ['runmod', moduleName]
    def args2 = runModArgs.split("\\s+")
    boolean ignoring = false
    for (String arg: args2) {
        if (arg == '-cp') {
            ignoring = true
        } else if (!ignoring) {
            args.add(arg)
        } else {
            ignoring = false
        }
    }
    args.add('-cp')
    args.add(classpath)
    Starter.main(args as String[])
}

task runMod(dependsOn: copyMod, description: 'Run the module using all the build dependencies (not using installed vertx') << {
    setSysProps()
    def args = ['runmod', moduleName]
    def args2 = runModArgs.split("\\s+")
    args.addAll(args2)
    Starter.main(args as String[])
}

task pullInDeps(dependsOn: copyMod, description: 'Pull in all the module dependencies for the module into the nested mods directory') << {
    if (pullInDeps == 'true') {
        setSysProps()
        def args = ['pulldeps', moduleName]
        Starter.main(args as String[])
    }
}

def log4jModule = project('skylle-log4j')

configure(log4jModule) {
    apply plugin: 'java'

    task log4jJar(dependsOn: classes, type: Jar) {
        destinationDir = file(programDir + '/integration')
        from log4jModule.sourceSets.main.output.classesDir
    }
}

task copyExecutable( type:Copy, description: 'Copy executable files (exe and sh) to result dir' ) {
    into programDir
    from "program"
}

task fatJar(dependsOn: modZip, description: 'Creates a fat executable jar which contains everything needed to run the module') << {
    setSysProps()
    def args = ['fatjar', moduleName, '-d', programDir]
    Starter.main(args as String[])
}

task assembleApp(dependsOn: [fatJar, copyExecutable, log4jModule.log4jJar]) {

}

def setSysProps() {
    System.setProperty("vertx.clusterManagerFactory", "org.vertx.java.spi.cluster.impl.hazelcast.HazelcastClusterManagerFactory")
    System.setProperty("vertx.mods", "build/mods")
}

def loadProperties(String sourceFileName) {
    def config = new Properties()
    def propFile = new File(sourceFileName)
    if (propFile.canRead()) {
        config.load(new FileInputStream(propFile))
        for (Map.Entry property in config) {
            project.ext[property.key] = property.value;
        }
    }
}

plugins.withType(IdeaPlugin) {
    idea {
        module {
            scopes.PROVIDED.plus += configurations.provided
            scopes.COMPILE.minus += configurations.provided
            scopes.TEST.minus += configurations.provided
            scopes.RUNTIME.minus += configurations.provided
        }
    }
}


buildscript {
    dependencies {
        classpath 'org.jooq:jooq-meta:3.2.0'
        classpath 'org.jooq:jooq-codegen:3.2.0'
        classpath 'org.jooq:jooq:3.2.0'
        classpath 'postgresql:postgresql:9.1-901.jdbc4'
    }
}


import org.jooq.util.GenerationTool
import org.jooq.util.jaxb.Configuration as JooqConfiguration
import org.jooq.util.jaxb.Generator
import org.jooq.util.jaxb.Database
import org.jooq.util.jaxb.Target
import org.jooq.util.jaxb.Jdbc
import javax.xml.bind.JAXB

task generateJooq() << {
    def jdbc = new Jdbc();
    def generator = new Generator();
    def configuration = new JooqConfiguration();
    def target = new Target();
    def database = new Database();

    def driver = org.postgresql.Driver.find();
    println("Found driver " + driver)
    def clazz = Thread.currentThread().getContextClassLoader().loadClass('org.postgresql.Driver')
    println("Found clazz " + clazz)

    jdbc.setDriver('org.postgresql.Driver')
    jdbc.setUrl("jdbc:postgresql://localhost/skylle")
    jdbc.setUser("root")
    jdbc.setPassword("root")

    target.setDirectory("${rootDir}/src/main/java")
    target.setPackageName("com.skylle.entities.generated")
    generator.setTarget(target)

    database.setInputSchema("public")
    database.setName("org.jooq.util.postgres.PostgresDatabase")
    database.setIncludes(".*")

    generator.setDatabase(database)

    configuration.setGenerator(generator)
    configuration.setJdbc(jdbc);


    StringWriter writer = new StringWriter();
    JAXB.marshal(configuration, writer);

    println("Using this configuration:\n" + writer.toString());
    GenerationTool.main(configuration);
}

dependencies {
  compile "org.codehaus.groovy:groovy-all:$groovyVersion"
  compile "io.vertx:lang-groovy:$groovyLangModVersion@jar"
  compile "org.jooq:jooq:3.2.0"
  compile "postgresql:postgresql:9.1-901.jdbc4"
}

